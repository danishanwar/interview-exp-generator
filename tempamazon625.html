<html><body>
<style>body {background-color: #fcf;color:#black; font-size:20px;font-family:Helvetica;}</style>
b'<article class="content post-135647 post type-post status-publish format-standard hentry category-interview-experiences tag-amazon" id="post-135647"><h1>Amazon Interview Experience | Set 231 (On-Campus)</h1><div class="media"><div class="meta"><ul><li><span class="strong">Difficulty Level :</span>\n<span><a href="https://www.geeksforgeeks.org/medium/">Medium</a></span><li><span class="strong">Last Updated :</span>\n<span>02 Jul, 2019</span></li></li></ul></div></div><div class="text"><p>We had Amazon campus interview in our college offering an internship (performance based job conversion).<p><strong><br/>First round(online coding round) :</strong><br/>20 MCQs.<br/>2 coding questions.<ol><li>Given three huge numbers, each represented using a linked list (where each node of a linked list represents a digit), calculate the sum of the numbers and return back the number in the form of a linked list. For example, \xc2\xa09-&gt;2-&gt;3, 4-&gt;6 and 2-&gt;5-&gt;1 representing numbers 923, 46 and 251 respectively. The result should be 1-&gt;2-&gt;2-&gt;0. This can be solved using stacks.<li><a href="https://practice.geeksforgeeks.org/problems/detect-cycle-in-a-directed-graph/1" rel="noopener" target="_blank">Given a graph, detect if it has a cycle.</a> We can perform a dfs here.</li></li></ol><p><strong>Second round(Technical Interview):</strong><br/>I was asked to explain my work at an internship that I did. I explained for about 10 minutes. I was then given a binary search tree and asked to form a mirror of it i.e. every parent nodes left and right child should be swapped. I wrote a simple recursive code for it.<pre>\r\nvoid BST(Node root) {\r\n  if (root==null)\r\n     return;\r\n  Node temp = root.left;\r\n  root.left = root.right;\r\n  root.right = temp;\r\n  BST(root.left);\r\n  BST(root.right);\r\n}</pre><p>Given a somewhat sorted array where the numbers are in ascending order first and then follow a descending order, find the index at which the order changes and return the number at that index. For example, i/p: 1234532, o/p: 5. I wrote down a modified binary search for it (had to take care of some corner cases). The interviewer was satisfied and I was sent to the next round.<p><strong><br/>Third round(Technical Interview):</strong><br/>I was asked to talk about one of the projects. I spoke about an artificial intelligence project that I did. He asked me some questions based on it. About 15 minutes.<br/>I was asked the same question as the first one in the online round except here I had to add only two numbers. I told him that but he asked me nonetheless to write the code down and explain it. I gave him the recursive solution as well as the easier stack-based solution as a replacement of recursion.<br/>Given positive numbers a1,a2\xe2\x80\xa6an, you can sum up the elements in the following way: 1*a(i%n)+2*a((i+1)%n)\xe2\x80\xa6+n*a((i+n)%n) where i ranges from 0 to n-1. Find the value of i at which this sum would be the maximum. For example, 5,6,7 the various sums can be 1*5+2*6+3*7, 1*6+2*7+3*5, and 1*7+2*5+3*6. The answer is 38.<br/>We can solve this in O(n). We initially calculate the sum for i being 0. We make the following observation.<div id="AP_G4GR_5"></div><p>i=0, sum0 = 1*a1+2*a2+3*a3\xe2\x80\xa6n*an.<br/>i=1, sum1 = n*a1+1*a2+2*a3\xe2\x80\xa6(n-1)an<br/>sum1 = sum0 \xe2\x80\x93 (a1+a2+\xe2\x80\xa6an) + n*a1<br/>Generalizing the equation: sumi \xc2\xa0= sumi-1 \xe2\x80\x93 (a1+a2+\xe2\x80\xa6an) + n*ai , where i ranges from 1 to n-1. The maximum of the sum0 to sumn-1 is the result.<br/>Next question, you need to create an application which listens to requests continuously. The application has a common file that it can access. For every request, some information from the file has to be retrieved and returned back. Would you spawn a new process for each request or a new thread. And why? I said thread since the main processing to be done is on a shared resource and by creating threads you do not need make a copy of the file as such resources can be shared between threads.<br/>What are the scheduling algorithms that you know in operating systems? What data structure would you use for each of the algorithms. I mentioned the following:<br/>First come First Serve : Queue.<br/>Priority based scheduling : Priority Queue.<br/>Shortest job First: Priority Queue ( this scheduling algorithm boils down to priority based scheduling)<br/>Round Robin : Circular Queue. Interviewer told me circular linked list suits the purpose better. I added that circular double linked list would be an even better answer because of more efficient deletion of an ith node. He told me you can do this operation efficiently in a single linked list itself. I thought for a while and agreed with him while also showing him how I would go about doing this operation in a single linked list.<br/>Given a computer with 1Gb ram and a 2Gb ram, the latter one would perform faster. Explain why would having more amount of ram would \xe2\x80\x93 in normal circumstances- fare better than lesser ram powered computer. Answer : paging. I also told him how in certain computations like external sorting, it would also be more efficient if you have more RAM.<br/><a href="https://practice.geeksforgeeks.org/problems/find-the-number-of-islands/1" rel="noopener" target="_blank">Given a matrix of 1\xe2\x80\x99s and 0\xe2\x80\x99s, where 1 represents an island and 0 water, find the number of islands formed</a>. The interviewer was expecting me to come up with a dfs solution similar to this one.(Unlike the problem given in link, the 1\xe2\x80\x99s can be connected only horzontally or vertically). But I had a quick union find(disjoint set problem) solution in mind.<p><strong><br/>Fourth round(Technical Interview):</strong><br/>I was asked about my internship work, again. I described the same one as I did in the first round. He asked me some questions based on it. We spent about 20 minutes on it.<br/><a href="https://practice.geeksforgeeks.org/problems/top-view-of-binary-tree/1" rel="noopener" target="_blank">Print the top view of a binary tree in order</a>, from left to right. I took some time to figure it out. As I was arriving at the solution I kept explaining it out loud. I had previously done a problem on printing right view of a binary tree which had a similar approach.<p>Given a number n, print all the squares of numbers such that the square is less than equal to n. For example, if n is 30, o/p: 1 4 9 16 25. Do this without using *,^ or division operations.<br/>If we observe the sequence we get from the output, to arrive at the next number in the sequence, we add the next odd number. So, 0+1=1, 1+3=4, 4+5=9, 9+7=16 and so on.<p>I have covered almost all of the questions asked to me. I had to wait for more than a week for the results. I got selected \xf0\x9f\x99\x82<p>If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.<p><div id="practiceCompanyLinkDiv"><div style="font-size:16px;color:#404040;font-weight:700;margin-bottom:20px"><a href="https://practice.geeksforgeeks.org/company/Amazon/">All Practice Problems for Amazon</a> !</div></div><div class="textBasedMannualAds_2"></div><div class="clear hideIt" id="personalNoteDiv"><div class="personalNoteHeader clear"><span class="noteHeaderText">My Personal Notes</span>\n<span class="hideNotesDivIcon"><i class="material-icons personalNotesIcon">arrow_drop_up</i></span></div><div class="collapsableDivPersonalNotes"><textarea class="personalNoteStyle" id="enteredPersonalNote" maxlength="5000" placeholder="Add your personal notes here! (max 5000 chars)"></textarea><div class="saveNoteDiv"><span class="processSaveNote"></span><button class="savePersonalNoteButton" onclick="saveUserPersonalNote()">Save</button></div></div></div></p></p></p></p></p></p></p></p></p></p></p></div></article>'
</html></body>
